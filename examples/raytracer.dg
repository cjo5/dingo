// Based on raytracing in one weekend:
// https://github.com/petershirley/raytracinginoneweekend

include "../std/lib.dg"

use math::sqrt
use math::pow
use math::pi
use math::tan

struct Vec3 {
    var x: Float
    var y: Float
    var z: Float

    fun normalize(&var Self) {
        val n = self.length()
        self.x = self.x/n
        self.y = self.y/n
        self.z = self.z/n
    }

    fun length(&Self) Float {
        return sqrt(self.length2()) as Float
    }

    fun length2(&Self) Float {
        return self.x*self.x + self.y*self.y + self.z*self.z
    }
}

fun unit_vector(v1: &Vec3) Vec3 {
    var v2 = v1[]
    v2.normalize()
    return v2
}

fun add(v1: &Vec3, v2: &Vec3) Vec3 {
    return Vec3(
        x: v1.x + v2.x,
        y: v1.y + v2.y,
        z: v1.z + v2.z,
    )
}

fun sub(v1: &Vec3, v2: &Vec3) Vec3 {
    return Vec3(
        x: v1.x - v2.x,
        y: v1.y - v2.y,
        z: v1.z - v2.z,
    )
}

fun mul(v1: &Vec3, v2: &Vec3) Vec3 {
    return Vec3(
        x: v1.x*v2.x,
        y: v1.y*v2.y,
        z: v1.z*v2.z,
    )
}

fun div(v1: &Vec3, v2: &Vec3) Vec3 {
    return Vec3(
        x: v1.x/v2.x,
        y: v1.y/v2.y,
        z: v1.z/v2.z,
    )
}

fun smul(s: Float, v: &Vec3) Vec3 {
    return Vec3(
        x: s*v.x,
        y: s*v.y,
        z: s*v.z,
    )
}

fun sdiv(v: &Vec3, s: Float) Vec3 {
    return Vec3(
        x: v.x/s,
        y: v.y/s,
        z: v.z/s,
    )
}

fun dot(v1: &Vec3, v2: &Vec3) Float {
    return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z
}

fun cross(v1: &Vec3, v2: &Vec3) Vec3 {
    return Vec3(
        x: v1.y*v2.z - v2.y*v1.z,
        y: -(v1.x*v2.z - v2.x*v1.z),
        z: v1.x*v2.y - v2.x*v1.y,
    )
}

fun reflect(v: &Vec3, n: &Vec3) Vec3 {
    return sub(
        v,
        smul(
            2*dot(v, n),
            n,
        ),
    )
}

fun refract(v: &Vec3, n: &Vec3, ni_over_nt: Float, refracted: &var Vec3) Bool {
    val uv = unit_vector(v)
    val dt = dot(uv, n)
    val discriminant = 1 - ni_over_nt*ni_over_nt*(1-dt*dt)
    if discriminant > 0 {
        refracted[] = sub(
            smul(
                ni_over_nt,
                sub(
                    uv,
                    smul(dt, n),
                ),
            ),
            smul(
                sqrt(discriminant) as Float,
                n,
            ),
        )
        return true
    }
    return false
}

fun schlick(cosine: Float, ref_idx: Float) Float {
    var r0 = (1-ref_idx)/(1+ref_idx)
    r0 = r0*r0
    return r0 + (1-r0)*(pow(1-cosine, 5) as Float) 
}

struct Ray {
    var origin: Vec3
    var dir: Vec3

    fun point_at_parameter(&Self, t: Float) Vec3 {
        return add(self.origin, smul(t, self.dir))
    }
}

val mat_lambertian = 1
val mat_metal = 2
val mat_dielectric = 3

struct Material {
    var kind: Int
    var albedo: Vec3
    var fuzz: Float
    var ref_idx: Float

    fun lambertian_scatter(
        &Self,
        ray_in: &Ray,
        rec: &HitRecord,
        attenuation: &var Vec3,
        scattered: &var Ray,
    ) Bool {
        val target = add(
                add(rec.p, rec.normal),
                random_in_unit_sphere(),
        )
        scattered[] = Ray(rec.p, sub(target, rec.p))
        attenuation[] = self.albedo
        return true
    }

    fun metal_scatter(
        &Self,
        ray_in: &Ray,
        rec: &HitRecord,
        attenuation: &var Vec3,
        scattered: &var Ray,
    ) Bool {
        val reflected = reflect(unit_vector(ray_in.dir), rec.normal)
        scattered[] = Ray(rec.p, add(reflected, smul(self.fuzz, random_in_unit_sphere())))
        attenuation[] = self.albedo
        return dot(scattered.dir, rec.normal) > 0
    }

    fun dielectric_scatter(
        &Self,
        ray_in: &Ray,
        rec: &HitRecord,
        attenuation: &var Vec3,
        scattered: &var Ray,
    ) Bool {
        var outward_normal: Vec3
        val reflected = reflect(ray_in.dir, rec.normal)
        var ni_over_nt: Float
        attenuation[] = Vec3(1, 1, 1)
        var refracted: Vec3
        var reflect_prob: Float
        var cosine: Float
        if dot(ray_in.dir, rec.normal) > 0 {
            outward_normal = smul(-1, rec.normal)
            ni_over_nt = self.ref_idx
            //cosine = self.ref_idx*dot(ray_in.dir, rec.normal)/norm(ray_in.dir)
            cosine = dot(ray_in.dir, rec.normal)/ray_in.dir.length()
            cosine = sqrt(1 - self.ref_idx*self.ref_idx*(1-cosine*cosine)) as Float
        } else {
            outward_normal = rec.normal
            ni_over_nt = 1/self.ref_idx
            cosine = -dot(ray_in.dir, rec.normal)/ray_in.dir.length()
        }
        if refract(ray_in.dir, outward_normal, ni_over_nt, &var refracted) {
            reflect_prob = schlick(cosine, self.ref_idx)
        } else {
            reflect_prob = 2
        }
        if randf32(0, 1) < reflect_prob {
            scattered[] = Ray(rec.p, reflected)
        } else {
            scattered[] = Ray(rec.p, refracted)
        }
        return true
    }

    fun scatter(
        &Self,
        ray_in: &Ray,
        rec: &HitRecord,
        attenuation: &var Vec3,
        scattered: &var Ray,
    ) Bool {
        if self.kind == mat_lambertian {
            return self.lambertian_scatter(ray_in, rec, attenuation, scattered)
        } elif self.kind == mat_metal {
            return self.metal_scatter(ray_in, rec, attenuation, scattered)
        }
        return self.dielectric_scatter(ray_in, rec, attenuation, scattered)
    }
}

struct HitRecord {
    var t: Float
    var p: Vec3
    var normal: Vec3
    var mat: &Material
}

struct Sphere {
    var center: Vec3
    var radius: Float
    var mat: Material

    fun hit(&Self, ray: &Ray, tmin: Float, tmax: Float, rec: &var HitRecord) Bool {
        val oc = sub(ray.origin, self.center)
        val a = dot(ray.dir, ray.dir)
        val b = dot(oc, ray.dir)
        val c = dot(oc, oc) - self.radius*self.radius
        val discriminant = b*b - a*c
        if discriminant > 0 {
            var tmp = (-b - sqrt(discriminant) as Float)/a
            if tmp < tmax and tmp > tmin {
                rec.t = tmp
                rec.p = ray.point_at_parameter(rec.t)
                rec.normal = sdiv(sub(rec.p, self.center), self.radius)
                rec.mat = &self.mat
                return true
            }
            tmp = (-b + sqrt(discriminant) as Float)/a
            if tmp < tmax and tmp > tmin {
                rec.t = tmp
                rec.p = ray.point_at_parameter(rec.t)
                rec.normal = sdiv(sub(rec.p, self.center), self.radius)
                rec.mat = &self.mat
                return true
            }
        }
        return false
    }
}

struct World {
    var spheres: &[Sphere]

    fun hit(&Self, r: &Ray, tmin: Float, tmax: Float, rec: &var HitRecord) Bool {
        var tmp_rec: HitRecord
        var hit_anything = false
        var closest_so_far = tmax
        for i: USize = 0; i < len(self.spheres); i++ {
            if self.spheres[i].hit(r, tmin, closest_so_far, &var tmp_rec) {
                hit_anything = true
                closest_so_far = tmp_rec.t
                rec[] = tmp_rec
            }
        }
        return hit_anything
    }
}

struct Camera {
    var origin: Vec3
    var lower_left_corner: Vec3
    var horizontal: Vec3
    var vertical: Vec3
    var u: Vec3
    var v: Vec3
    var w: Vec3
    var lens_radius: Float

    fun get_ray(&Self, s: Float, t: Float) Ray {
        val rd = smul(self.lens_radius, random_in_unit_disk())
        val offset = add(
            smul(rd.x, self.u),
            smul(rd.y, self.v),
        )
        return Ray(
            origin: add(
                self.origin,
                offset,
            ),
            dir: sub(
                sub(
                    add(
                        self.lower_left_corner,
                        add(
                            smul(s, self.horizontal),
                            smul(t, self.vertical),
                        ),
                    ),
                    self.origin,
                ),
                offset,
            ),
        )
    }
}

fun create_camera(
    lookfrom: Vec3,
    lookat: Vec3,
    vup: Vec3,
    vfov: Float,
    aspect: Float,
    aperture: Float,
    focus_dist: Float,
) Camera {
    var cam = Camera()
    cam.lens_radius = aperture/2
    val theta = vfov*pi/180
    val half_height = tan(theta/2) as Float
    val half_width = aspect*half_height
    cam.origin = lookfrom
    cam.w = unit_vector(sub(lookfrom, lookat))
    cam.u = unit_vector(cross(vup, cam.w))
    cam.v = cross(cam.w, cam.u)
    cam.lower_left_corner = sub(
        sub(
            sub(
                cam.origin,
                smul(half_width*focus_dist, cam.u),
            ),
            smul(half_height*focus_dist, cam.v),
        ),
       smul(focus_dist, cam.w),
    )
    cam.horizontal = smul(2*half_width*focus_dist, cam.u)
    cam.vertical = smul(2*half_height*focus_dist, cam.v)
    return cam
}

fun random_in_unit_sphere() Vec3 {
    var p = Vec3(1, 1, 1)
    while p.length2() > 1 {
        p = sub(
            smul(
                2,
                Vec3(
                    x: randf32(0, 1),
                    y: randf32(0, 1),
                    z: randf32(0, 1),
                ),
            ),
            Vec3(1, 1, 1),
        )
    }
    return p
}

fun random_in_unit_disk() Vec3 {
    var p = Vec3(1, 1, 0)
    while dot(p, p) >= 1 {
        p = sub(
            smul(
                2, 
                Vec3(
                    x: randf32(0, 1),
                    y: randf32(0, 1),
                    z: 0,
                ),
            ),
            Vec3(1, 1, 0),
        )
    }
    return p
}

fun color(ray: &Ray, world: &World, depth: Int) Vec3 {
    var rec: HitRecord
    if world.hit(ray, 0.001, 1e37, &var rec) {
        var scattered: Ray
        var attenuation: Vec3
        if depth < 50 and rec.mat.scatter(ray, rec, &var attenuation, &var scattered) {
            return mul(
                attenuation,
                color(scattered, world, depth+1),
            )
        } 
        return Vec3(0, 0, 0)
    }
    val unit_dir = unit_vector(ray.dir)
    val t = 0.5*(unit_dir.y + 1)
    return add(Vec3(1-t, 1-t, 1-t), Vec3(t*0.5, t*0.7, t*1.0))
}

fun randf32(min: Float, max: Float) Float {
    var div = 100
    return ((libc::rand()%div) as Float)/(div as Float)*(max - min) + min
}

fun random_scene(list: &var [Sphere]) {
    list[0] = Sphere(
        center: Vec3(0, -1000, 0),
        radius: 1000,
        mat: Material(
            kind: mat_lambertian,
            albedo: Vec3(0.5, 0.5, 0.5),
        ),
    )
    var i = 1
    for a = -11; a < 11; a++ {
        for b = -11; b < 11; b++ {
            val choose_mat = randf32(0, 1)
            val center = Vec3((a as Float)+0.9*randf32(0, 1), 0.2, (b as Float)+0.9*randf32(0, 1))
            if sub(center, Vec3(4,0.2,0)).length() > 0.9 {
                if choose_mat < 0.8 { // diffuse
                    list[i] = Sphere(
                        center: center,
                        radius: 0.2,
                        mat: Material(
                            kind: mat_lambertian,
                            albedo: Vec3(
                                randf32(0,1)*randf32(0,1),
                                randf32(0,1)*randf32(0,1),
                                randf32(0,1)*randf32(0,1),
                            ),
                        ),
                    )
                } elif choose_mat < 0.95 { // metal
                    list[i] = Sphere(
                        center: center,
                        radius: 0.2,
                        mat: Material(
                            kind: mat_metal,
                            albedo: Vec3(
                                0.5*(1+randf32(0,1)),
                                0.5*(1+randf32(0,1)),
                                0.5*(1+randf32(0,1)),
                            ),
                            fuzz: 0.5*randf32(0,1),
                        ),
                    )

                } else { // glass
                    list[i] = Sphere(
                        center: center,
                        radius: 0.2,
                        mat: Material(
                            kind: mat_dielectric,
                            ref_idx: 1.5,
                        ),
                    )
                }
                i++
            }
        }
    }
    list[i] = Sphere(
        center: Vec3(0, 1, 0),
        radius: 1,
        mat: Material(
            kind: mat_dielectric,
            ref_idx: 1.5,
        ),
    )
    i++
    list[i] = Sphere(
        center: Vec3(-4, 1, 0),
        radius: 1,
        mat: Material(
            kind: mat_lambertian,
            albedo: Vec3(0.4, 0.2, 0.1),
        ),
    )
    i++
    list[i] = Sphere(
        center: Vec3(4, 1, 0),
        radius: 1,
        mat: Material(
            kind: mat_metal,
            albedo: Vec3(0.7, 0.6, 0.5),
            fuzz: 0,
        ),
    )
}

fun trace() {
    val nx = 1200
    val ny = 800
    val ns = 10

    io::println("P3")
    io::printi(nx)
    io::print(" ")
    io::printiln(ny)
    io::printiln(255)

    var spheres: [Sphere:501]
    random_scene(&var spheres[:])
    val world = World(
        spheres: &spheres[:],
    )

    val lookfrom = Vec3(13, 2, 3)
    val lookat = Vec3(0, 0, 0)
    val dist_to_focus = 10.0
    val aperture = 0.1

    var cam = create_camera(
        lookfrom: lookfrom,
        lookat: lookat,
        vup: Vec3(0, 1, 0),
        vfov: 20,
        aspect: nx as Float / ny as Float,
        aperture: aperture,
        focus_dist: dist_to_focus,
    )

    for j = ny-1; j >= 0; j-- {
        for i = 0; i < nx; i++ {
            var col: Vec3
            for s = 0; s < ns; s++ {
                val u = (i as Float + randf32(0, 1)) / nx as Float
                val v = (j as Float + randf32(0, 1)) / ny as Float
                val ray = cam.get_ray(u, v)
                col = add(col, color(ray, world, 0))
            }
            col = sdiv(col, ns as Float)
            col = Vec3(
                x: sqrt(col.x) as Float,
                y: sqrt(col.y) as Float,
                z: sqrt(col.z) as Float,
            )
            val ir = (255.99*col.x) as Int
            val ig = (255.99*col.y) as Int
            val ib = (255.99*col.z) as Int
            io::printi(ir)
            io::print(" ")
            io::printi(ig)
            io::print(" ")
            io::printiln(ib)
        }
    }
}

extern fun main() C_int {
    trace()
    return 0
}
