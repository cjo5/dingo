module main

import "std/math"
import "builtin"
import "mylib" (
    val Shape, var PI, struct Code, func man, enum x
)

main() {

}

rst func main() {

}

int func main() -> bool {

}

ext func main() {

}

/*
    @std: standard library
    @file: relative to file's parent directory

    module IDENT defines a module. 
    A module can be a single file: file name is same as module.
    A module can be a directory: entry point for module is module.lang file.
    A module defines build options.

    3 levels of visibility:
    - external: accessible outside module.
    - internal: acccessible by other files in same module.
    - restricted: only accessible inside file.
*/

/*

Base types:
- Unsigned / signed 64, 32, 16 and 8 bit integers
- 64 and 32 bit floats
- char
- bool
- function
- struct
- enum
- array

func main() {
    // type annotations
    var x1: geometry = geometry{}; // named struct
    val x2: *{a: i32, b: i32} = {a = 5, b = 6}; // anonymous struct
    var y: geometry = geometry::shape; // enum
    var z: [5]geometry = []; // static array
    val v1: *geometry = new geometry{}; // pointer
    val v2: []geometry = new [5]geometry; // slice
    var w: (i32, i32) -> bool = func (a: i32, b: i32) -> bool { // function
        return a < 5;
    };

    // inference
    var x1 = geometry{}; // named struct
    var x2 = {a=5, b=6}; // anonymous struct
    var y = geometry::shape; // enum
    var z = [1, 2, 3]; // array
    var v1 = new geometry{}; // pointer
    var v2 = new [5]geometry // slice
    var w = func(a: i32, b: i32) -> bool {
        return < 5;
    };

    val ptr x: geometry = &x;
    var ptr z
}

ext struct data<T> [Parent<T>] {
    rst static CONSTANT: f32 = 6,
    ext val x: f32 = 5.0,
    rst y: f32 = 6.0,
    int var y: i64 =a5,
}

interface x {
    api() -> bool;
}

def x [Y] {
    mul(a: i32, b: i32) -> i32 {
        return a * b;
    } 
}


let z: []int = 5;

var x: str = ""

var x: u8
var x: s8

struct {
    v: s32 = 99
    w: s32
} a;


val f: (s32, u64) -> i32 = fun (a: s32, b: s32) -> i32 {

};

var f2: (a: str, b: str) -> i32;

let f: {a: s32, b: s32} = struct {
    a = 9,
    b = 9
};

let f = fun (a, b) -> i32 {

};

*/