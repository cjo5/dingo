module main;

import @std/math;
import @builtin;
import @mylib;
import handler;

ex fun abc() {

}

in fun() {
    
}

/*
    @std: standard library
    @file: relative to file's parent directory

    module IDENT; defines a module. 
    A module can be a single file: file name is same as module.
    A module can be a directory: entry point for module is module.lang file.
    A module defines build options.

    3 levels of visibility:
    - external (extr): accessible outside module.
    - internal (intr): acccessible by other files in same module.
    - default: only accessible inside file.


*/

/*

Base types:
- Unsigned / signed 64, 32, 16 and 8 bit integers
- 64 and 32 bit floats
- char
- bool
- function
- struct
- enum
- array

fun main() {
    // type annotations
    var x1: geometry = geometry{}; // named struct
    var x2: {a: i32, b: i32} = struct{a = 5, b = 6}; // anonymous struct
    var y: geometry = geometry::shape; // enum
    var z: [5]geometry = []; // array
    val v: *geometry = new geometry{} // pointer
    var w: (i32, i32) -> bool = fun(a: i32, b: i32) -> bool { // function
        return a < 5;
    };

    var w: (i32, i32) -> bool = || -> bool {

    };

    // inference
    var x1 = geometry{} // named struct
    var x2 = struct{a=5, b=6}; // anonymous struct
    var y = geometry.shape; // enum
    var z = [1, 2, 3] // array
    var v = new geometry{} // pointer
    var w = fun(a: i32, b: i32) -> bool {
        return < 5;
    };

    val ptr x: geometry = &x;
    var ptr z
}

val x {x: {z: f32}, y: f32} = {x={z=2}, y=9};

struct x {
    ex var a: {
        a: i32,
        b: i32
    } = {a=5, b=6}, 
    ex var a: {a: i32, b: i32} = {a=5, b=6},
    ex val a: f32 = 5,
    in val b: f32: 5,
    ex static b: f32 = 5.0,
}

enum x {

}

fun x {
}

interface x [Parent] {

}

alias circle2: circle;

fun normalize(x: str) -> {a: i64, b: str} {
    var x : returntype;
    x.a = 99;
    return x;
}

false.u64()

val x: u64 = 99;
let y: u32 = 55;
let z: u32 = x.u32() * y;

u32.max
i32.min
u8.max

let z: []int = 5;

var x: str = ""

var x: u8
var x: s8

struct {
    v: s32 = 99
    w: s32
} a;


val f: (s32, u64) -> i32 = fun (a: s32, b: s32) -> i32 {

};

var f2: (a: str, b: str) -> i32;

let f: {a: s32, b: s32} = struct {
    a = 9,
    b = 9
};

let f = fun (a, b) -> i32 {

};

*/