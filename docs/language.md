# The Dingo Language

## Index

- [Files and Modules](#files-and-modules)
- [Comments](#comments)
- [Semicolons](#semicolons)
- [Variables](#variables)
- [Typealias](#typealias)
- [Functions](#functions)
- [References / Pointers](#references--pointers)
- [Arrays](#arrays)
- [Slices](#slices)
- [Structs](#structs)
- [Type Casting](#type-casting)
- [If](#if)
- [For / While](#for--while)
- [Defer](#defer)
- [Sizeof](#sizeof)
- [Memory Management](#memory-management)
- [C](#c)
- [Strings](#strings)
- [Booleans](#Booleans)
- [Numbers](#numbers)
- [Basic Operators](#other-operators)
- [Assignments](#assignments)
- [Grammar](grammar.md)
- [Operator Precedence](#operator-precedence)
- [Keywords](#keywords)

## Files and Modules

A module is a namespace for grouping related code. Modules can be nested, in which case they share a common prefix.
An identifier's Fully Qualified Name (FQN) is the path from the root module to the identifier.
Modules and top-level identifiers are either public ```pub``` or private ```priv``` (default).
The visibility of parent modules do not affect the visibility of child modules.

```rust
module foo {            // FQN: foo
    var bar I32         // FQN: foo.bar
    pub module baz {    // FQN: foo.baz
        pub var qux I32 // FQN: foo.baz.qux
    }
}
```

A file can be included inside another file and module. This is equivalent to replacing the include statement with the included file's content.
The FQN of every identifier in the included file is prefixed with the FQN of the module where it's included.
The include path is either absolute or relative to the file with the include statement.

a.dg:

```rust
var bar I32
module baz {
    var qux I32
}
```

b.dg:

```rust
module foo {
    include "a.dg"
    // The identifiers in a.dg are brought in to the foo module.
    // FQN: foo.bar
    // FQN: foo.baz
    // FQN: foo.baz.qux
}
```

A compilation unit (cunit) is a root file (passed as argument to dgc) plus all its included files.
Files are included in a breadth-first search manner and are loaded automatically during the parsing phase.
Compilation units have a one-to-one correspondence to object files generated by the compiler.

Multiple modules can be defined in the same cunit, as long as each module has a unique FQN within that cunit.
A module can access any other module/identifier defined in the same cunit.
Name lookups inside a module are relative by default. Absolute name lookups are prefixed with '.'.
Parent modules are not automatically searched in relative lookups. To lookup a name in a parent module, prefix the name with 'msuper'.
Name lookup is similar to how file system navigation on the command line works, where modules are directories and the final non-module identifier is the file.

```rust
fun hello() {}

module foo {
    fun bar() {
        hello()    // error
        .hello()   // ok
        baz.quux() // ok
    }
    module baz {
        fun qux() {
            bar()                 // error
            msuper.bar()          // ok
            msuper.msuper.hello() // ok
        }
        fun quux() {}
    }
}
```

A compilation context is a set of cunits. Modules defined in different cunits must be imported before they can be accessed.
A module can only be imported if it's declared as public. Every public module must have a unique FQN in a compilation context.
It's allowed to have modules in different cunits with the same FQN if at most one of them is public.
There are two types of import keywords: 'import' and 'importlocal'. 'import' searches for public modules in the same compilation context and 'importlocal' searches for local modules defined in the same cunit (public or private).

a.dg:

```rust
module foo {
    importlocal bar: h1 = hello // ok
    import baz: h2 = hello      // ok
    import qux                  // error, not public

    fun hello{}
}

module bar {
    fun hello{}
}
```

b.dg:

```rust
pub module baz {
    pub fun hello{}
}

module qux {
    pub fun hello{}
}
```

**Summary**

- A compilation unit (cunit) is root file + includes.
- Files can be included inside any module.
- Modules in the same cunit can be accessed directly.
- Modules in different cunits must be imported before they can be accessed.
- A module must be unique in a cunit and a public module must be unique in a compilation context.
- There are three types of module scopes: self, parent and root.
    The self scope is used by default, '.' prefix uses root scope, and 'msuper' prefix uses parent scope.
- import looks up public modules in the same compilation context.
- importlocal looks up local modules in the same compilation unit.

## Comments

```rust
// Single line comment.

/*
    Mutiline comment.
    Another comment.
    /*
        Nested comment.
    */
*/
```

## Semicolons

Semicolons work in a similar way as in Go. That is, the grammar and parser assume that statements are terminated with semicolons; however, the lexer automatically inserts a semicolon in the token stream at the end of a line if it sees a token that can terminate a statement. See [here](https://github.com/cjo5/dingo/blob/d9bde812c35417635c3d221e262d2ec4b61acfe2/internal/frontend/lex.go#L169) for the exact tokens that the lexer checks for.

## Variables

```rust
var a: I32
var b: I32 = 1
var c = 2
val d: I32
val e: I32 = 1
val f = 2
```

```var``` defines a mutable variable and ```val``` defines an immutable value. The type can be omitted when there is an initializer. The variable/value is assigned a default value if there is no initializer.

## Typealias

```rust
typealias Id = I32
```

Create an alias for a type. The two types are equivalent, and either type can be substituted for the other.

## Functions

```rust
fun say_hello() {
    println("hello")
}

fun add(a: I32, b: I32) I32 {
    return a + b
}

fun inc(var a: I32) I32 {
    a += 1
    return a
}

say_hello()
add(a: 5, b: 10)    // named arguments
add(6, 11)          // positional arguments
```

No return type means the function has no return value. Function calls support named arguments in arbitrary order. There can be no positional arguments after a named argument.
Function parameters are immutable by default, but can be made mutable by preceeding the name with 'var'.

Functions can be used as values and also defined inline (function literals). Though note that function literals are not closures and do not have access to variables in the enclosing scope.

```rust
val add_val: fun (I32, I32) I32 = add
val sub = fun(a: I32, b: I32) I32 {
    return a - b
}
```

## References / Pointers

```rust
var a: I32 = 5
val b: &I32 = &a         // immutable reference
val c: &var I32 = &var a // mutable reference
val d: &I32 = null       // default value

// dereference
b[] = 5 // error, b is an immutable reference
c[] = 9 // ok

val e = 6
val f = &var e // error, cannot take a mutable reference to an immutable value
```

## Arrays

```rust
var a: [I32:5] = [I32](1, 2, 3, 4, 5) // allocated on the stack
len(a) // length of array
```

## Slices

```rust
var a = [I32](1, 2, 3, 4, 5)
val b: &[I32] = &a[1:3]          // immmutable slice
val c: &var [I32] = &var a[:3]   // mutable slice
val d: &[I32] = null             // default value

len(c) // length of slice
```

## Structs

```rust
struct Foo {
    // fields

    a: I32              // immutable
    b: I32              // ...
    var count: I32      // mutable

    // methods

    // equivalent to self: &Self
    fun add(&Self) I32 {
        return self.a + self.b
    }

    // equivalent to self: &Foo
    fun sub(self: &Self) I32 {
        return self.a - self.b
    }

    // the struct name can be specified explicitly
    fun mul(self: &Foo) I32 {
        return f.a*f.b
    }

    // the parameter can have any custom name
    fun div(f: &Self) I32 {
        return f.a/f.b
    }

    // mutable parameter
    fun inc(&var Self) {
        self.count++
    }

    fun set(&var Self, a: I32, b: I32) {
        self.a = a
        self.b = b
    }

    fun say_hello() {
        println("hello")
    }
}

// allocated on the stack
var f1 = Foo(a: 5, b: 9)    // named arguments
val f2 = Foo(6, 10)         // positional arguments

f1.inc()
f1.add()
f1.sub()
f1.mul()
f1.div()
f1.set(7, 11)
f2.inc()        // invalid, f2 is immutable and inc takes a mutable reference
f2.say_hello()  // invalid, say_hello does not take Foo as first argument

```

Values are automatically dereferenced for field access and referenced when calling methods.

```Self``` is a ```typealias``` of the struct in methods. If the first parameter name is omitted in the function signature, then ```self``` is automatically inserted if the type is the struct (or ```Self```) or a reference to it; that is, the types that can be used with the dot operator. Other than these two conveniences methods are exactly the same as normal functions.


## Type Casting

```rust
val a: I64 = 5
val b = a as I32
```

## If

```rust
val a = 5
if a > 5 {
    println("Big")
} elif a < 5 {
    println("Small")
} else {
    println("OK")
}
```

Braces required.

## For / While

```rust
for i = 0; i < 5; i++ {     // i immutable
    printiln(i)
}

for var i = 0; i < 5; i++ { // i mutable
    printiln(i)
    i++
}

var i = 0
while true {
    i++
    if (i % 2) == 0 {
        continue
    } elif i == 5 {
        break
    }
    printiln(i)
}
```

Braces required. ```continue``` and ```break``` as expected.

## Defer

```rust
{
    defer println("Bye")
    defer printiln(3)
    defer printiln(2)
    defer printiln(1)
    println("Hello")
}
// output:
// Hello
// 1
// 2
// 3
// Bye
```

Defer execution of a statement until the end of the block. If a defer is executed, the deferred statement is guaranteed to be executed at the end of the enclosing scope, regardless of the control flow. The deferred statements are executed in reverse order of the defers.

## Sizeof

```rust
sizeof(I8)      // 1
sizeof(I64)     // 8
sizeof([I32:5]) // 4*5 = 20
```

Get the size of a type in bytes.

## Memory Management

Dynamic memory management is currently handled through the C API.

## C

Features to interface with the C ABI and runtime.

**Types**

```
C_void
C_char
C_uchar
C_short
C_ushort
C_int
C_uint
C_longlong
C_ulonglong
C_USize
C_float
C_double
```

References are currently used for C pointers, though no pointer arithmetic is allowed.

**Functions**

```rust
// Functions defined in C can be called from Dingo
extern fun free(ptr: &C_void)
extern fun malloc(size: C_usize) &var C_void

// Functions defined in Dingo can be called from C
extern fun do_stuff() {
    //...
}
```

Using ```extern``` on functions will enable C ABI and disable name mangling.

**main**

```rust

extern fun main(argc: C_int, argv: &&C_char) C_int {
    return 0
}
```

Main function in Dingo.

## Strings

There are two types of string literals: normal and C-like. Normal string literals are immutable slices, and C-like strings are immutable references. Both string types are null-terminated.

```rust
val a: &[I8] = "Hello"
val b: &I8 = c"Bye
```

## Booleans

```rust
val a: Bool = true
val b = false
```

## Numbers

**Types**

```rust
// signed integers
I8
I16
I32
I64
// unsigned integers
U8
U16
U32
U64
USize
// floating point
F32
F64
```

**Literal Samples**

```rust
15      // plain integer literal
100_000 // underscores to make large numbers more readable
100u8   // literals can have any numeric type as a suffix
0xFF    // hex
077     // octal
3.14    // plain floating point literal
1.234e2 // scientific notation: 1.234*10^2
1.234E2
```

## Basic Operators

**Binary Operators**

```rust
a + b   // addition
a - b   // subtraction
a * b   // mutliplication
a / b   // division
a % b   // remainder

a >= b  // greater than or equal to
a <= b  // less than or equal to
a == b  // equality
a != b  // inequality

// lazily evaluted
a and b // logical and
a or b  // logical or
```

**Unary Operators**

```rust
-a      // numerical negation
not a   // logical negation
```

## Assignments

```rust
a = 2   // normal assignment
a += 2  // a = a + 2
a -= 2  // a = a - 2
a *= 2  // a = a * 2
a /= 2  // a = a / 2
a %= 2  // a = a % 2
a++     // a = a + 1
a--     // a = a - 1
```

All assignments are statements.

## Grammar

See [grammar](grammar.md).

## Operator Precedence

```
Precedence  Associativity   Operation
1           None            (exp) len(a) sizeof(a) literal identifier
2           Left-to-right   a() a[] a[i] a[i:j] a.b
3           None            not -a &a
4           None            a as b
5           Left-to-right   a*b a/b a%b
6                           a+b a-b
7                           < <= > >=
8                           == !=
9                           and
10                          or
```

## Keywords

```
and
as
break
continue
defer
elif
else
extern
false
for
fun
if
import
importlocal
include
len
module
mself
msuper
not
null
or
priv
pub
return
sizeof
struct
true
typealias
val
var
while
```
