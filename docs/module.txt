A module is a namespace and provides a way to group related code and avoid name collisions.
Modules can be nested, in which case they share a common prefix.
An identifier's Fully Qualified Name (FQN) is the path from the root module to the identifier.

module foo {          // FQN: foo
    var bar i32       // FQN: foo.bar
    module baz {      // FQN: foo.baz
        var qux i32   // FQN: foo.baz.qux
    }
} 

A file can be included inside another file and module.
This is equivalent to copy the included file's content and paste it to where the include statement is.
The FQN of every identifier in the included file is prefixed with the FQN of the module where it's included.
The include path is either absolute or relative to the file with the include statement.

a.dg:
module foo {
    include "b.dg"
    // The identifiers in "b.dg" are brought in to the foo module.
    // FQN: foo.bar
    // FQN: foo.baz
    // FQN: foo.baz.qux
}

b.dg:
var bar i32
module baz {
    var qux i32    
}

A compilation unit (cunit) is a root file (passed as argument to dgc) and all its included files.
Files are included in a breadth-first search manner and are loaded automatically during the parsing phase.
Compilation units are similar to translation units in C++ and have a one-to-one correspondence to object files generated by the compiler.

Multiple modules can be defined in the same cunit as long as each module has a unique FQN within that cunit.
A module can access any other module/identifier defined in the same cunit.
Name lookups inside a module are relative by default. Absolute name lookups are prefixed with '.'.
Parent modules are not automatically searched in relative lookups. To lookup a name in a parent module, prefix the name with 'msuper'.
Name lookup is similar to how file system navigation on the command line works, where modules are directories and the final non-module identifier is the file.

a.dg:
fun hello() {}

module foo {
    fun bar() {
        hello()   // error
        .hello()  // ok
        baz.quux() // ok
    }
    module baz {
        fun qux() {
            bar()                 // error
            msuper.bar()          // ok
            msuper.msuper.hello() // ok
        }
        fun quux() {}
    }
}

A compilation context is a set of cunits. Modules defined in different cunits must be imported before they can be accessed.
A module can only be imported if it's declared as public. Every public module must have a unique FQN in a compilation context,
though it's allowed to have two modules in different cunits with the same FQN if at least one of them is private.
There are two types of import keywords: 'import' and 'importlocal'. import searches public modules in the compilation context.
importlocal searches local modules defined in the same cunit. 

a.dg:
module foo {
    importlocal bar: h1 = hello // ok
    import baz: h2 = hello      // ok
    import qux                  // error, not public

    fun hello{}
}

module bar {
    fun hello{}
}

b.dg:
pub module baz {
    pub fun hello{}
}

module qux {
    pub fun hello{}
}

Summary:
- A compilation unit (cunit) is root file + includes.
- Files can be included inside any module.
- Modules in the same cunit can be accessed directly.
- Modules in different cunits must be imported before they can be accessed.
- A module must be unique in a cunit and a public module must be unique in a compilation context.
- There are three types of module scopes: self, parent and root.
    The self scope is used by default. '.' prefix uses root scope and 'msuper' prefix uses parent scope.
- import looks up public modules in the compilation context.
- importlocal looks up local modules in the same compilation unit.
